"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
/**
 * Get the longest array of array of arrays
 *
 * @param {any[][]} array
 * @returns {{ index: number; array: any[]; length: number }}
 */
exports.getLongestArray = (array) => {
    const index = array.reduce((p, c, i, a) => (a[p].length > c.length ? p : i), 0);
    const longest = array[index];
    return { index, array: longest, length: longest.length };
};
/**
 * Convert number to A1 notation
 *
 * @param {number} col
 * @returns {string}
 */
exports.colToA = (col) => {
    if (col < 1)
        throw 'col has to be greater than 1';
    const { length } = ALPHABET;
    let div = col;
    let columnLabel = '';
    while (div) {
        let mod = div % length;
        div = Math.floor(div / length);
        if (mod == 0) {
            mod = ALPHABET.length;
            div -= 1;
        }
        columnLabel = `${ALPHABET[mod - 1]}${columnLabel}`;
    }
    return columnLabel;
};
/**
 * Convert A1 notation to number
 *
 * @param {string} label
 * @returns {number}
 */
exports.aToCol = (label) => {
    const match = label.match(/[A-Z]+/);
    if (!match || match[0].length !== label.length)
        throw `Label has to be uppercase alphabet letter but is "${label}"`;
    const col = label
        .split('')
        .reverse()
        .reduce((col, char, i) => {
        return col + (char.charCodeAt(0) - 64) * ALPHABET.length ** i;
    }, 0);
    return col;
};
/**
 * Parse a1Notation to col and row
 *
 * @param {string} [a1Notation='']
 * @returns {{ col: number; row: number }}
 */
const parseA1Notation = (a1Notation = '') => {
    return a1Notation.split('').reduce((red, part) => {
        if (part && !parseInt(part)) {
            return Object.assign(Object.assign({}, red), { col: exports.aToCol(part) });
        }
        return Object.assign(Object.assign({}, red), { row: parseInt(part) });
    }, { col: 0, row: 0 });
};
/**
 * Parse a range from a1Notation to options
 *
 * @param {GoogleSheetCli.QueryOptions} [options={}]
 * @returns {GoogleSheetCli.QueryOptions[]}
 */
exports.parseRanges = (options = {}) => {
    if (!options.range)
        return [options];
    const [title, a1Notations = ''] = options.range.split('!');
    let worksheetTitle = title;
    const sanitized = title.match(/^['"](.*)['"]$/);
    if (sanitized) {
        worksheetTitle = sanitized[1];
    }
    return a1Notations
        .replace(/[,;]/g, ',')
        .split(',')
        .map(a1Notation => {
        const [from, to] = a1Notation.split(':');
        const { col: minCol, row: minRow } = parseA1Notation(from);
        const { col: maxCol, row: maxRow } = parseA1Notation(to);
        if (!minCol && !minRow && !maxCol && !maxRow) {
            return Object.assign(Object.assign({}, options), { worksheetTitle });
        }
        return Object.assign(Object.assign({}, options), { maxCol: maxCol || minCol, minCol, maxRow: maxRow || minRow, minRow,
            worksheetTitle });
    });
};
/**
 * Convert query options to range notation
 *
 * @param {GoogleSheetCli.QueryOptions} [options={}]
 * @returns {string}
 */
exports.getRange = (options = {}) => {
    const { minCol, minRow, maxCol, maxRow, worksheetTitle, range } = options;
    if (range)
        return range;
    const title = `'${worksheetTitle}'`;
    if (!minCol && !minRow && !maxCol && !maxRow)
        return title;
    if (!maxCol && !maxRow)
        return `${title}!${exports.colToA(minCol || 1)}${minRow || 1}`;
    return `${title}!${exports.colToA(minCol || 1)}${minRow || 1}:${maxCol ? exports.colToA(maxCol) : ''}${maxRow || ''}`;
};
