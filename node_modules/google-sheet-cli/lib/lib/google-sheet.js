"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const googleapis_1 = require("googleapis");
const lodash_get_1 = tslib_1.__importDefault(require("lodash.get"));
const utils_1 = require("./utils");
var GoogleSheetCli;
(function (GoogleSheetCli) {
    let ValueInputOption;
    (function (ValueInputOption) {
        ValueInputOption["USER_ENTERED"] = "USER_ENTERED";
        ValueInputOption["RAW"] = "RAW";
    })(ValueInputOption = GoogleSheetCli.ValueInputOption || (GoogleSheetCli.ValueInputOption = {}));
})(GoogleSheetCli = exports.GoogleSheetCli || (exports.GoogleSheetCli = {}));
const GOOGLE_FEED_URL = 'https://spreadsheets.google.com/feeds/';
/**
 * GoogleSheet helper class for CRUD operations
 *
 * @export
 * @class GoogleSheet
 */
class GoogleSheet {
    /**
     * Creates an instance of GoogleSheet.
     * @param {string} [spreadsheetId]
     * @param {string} [worksheetTitle]
     * @memberof GoogleSheet
     */
    constructor(spreadsheetId, worksheetTitle) {
        this.spreadsheetId = spreadsheetId;
        this.worksheetTitle = worksheetTitle;
    }
    /**
     * Authorize with credentials
     *
     * @param {GoogleSheetCli.Credentials} credentials
     * @returns {Promise<void>}
     * @memberof GoogleSheet
     */
    async authorize(credentials) {
        credentials.private_key = credentials.private_key.replace(/\\n/g, '\n');
        // Create the JWT client
        const auth = await googleapis_1.google.auth.getClient({ credentials, scopes: [GOOGLE_FEED_URL] });
        this.sheets = googleapis_1.google.sheets({ version: 'v4', auth });
    }
    /**
     * Get information about the spreadsheet.
     *
     * @param {string} [spreadsheetId]
     * @returns {Promise<sheets_v4.Schema$Spreadsheet>}
     * @memberof GoogleSheet
     */
    async getSpreadsheet(spreadsheetId) {
        const { data: sheet } = await this.sheets.spreadsheets.get({
            spreadsheetId: spreadsheetId || this.spreadsheetId,
        });
        if (!sheet)
            throw `Spreadsheet "${spreadsheetId || this.spreadsheetId}" not found`;
        return sheet;
    }
    /**
     * Get information about the worksheet.
     *
     * @param {string} title
     * @param {string} [spreadsheetId]
     * @returns {Promise<sheets_v4.Schema$Sheet>}
     * @memberof GoogleSheet
     */
    async getWorksheet(title, spreadsheetId) {
        const { sheets = [], properties: { title: ssTitle = '' } = {} } = await this.getSpreadsheet(spreadsheetId);
        const sheet = sheets.find(({ properties: { title: ws } = {} }) => ws === title);
        if (!sheet)
            throw `Sheet "${title}" not found in "${ssTitle}"`;
        this.worksheetTitle = lodash_get_1.default(sheet, 'properties.title');
        return sheet;
    }
    /**
     * Get the data of the specified cells (or every available cell data)
     *
     * @param {GoogleSheetCli.QueryOptions} [options={}]
     * @param {string} [spreadsheetId]
     * @returns {Promise<GoogleSheetCli.SheetData>}
     * @memberof GoogleSheet
     */
    async getData(options = {}, spreadsheetId) {
        options.worksheetTitle = options.worksheetTitle || this.worksheetTitle;
        const parsedOptions = utils_1.parseRanges(options)[0];
        const { worksheetTitle: wsTitle } = parsedOptions;
        if (!wsTitle) {
            throw 'Option property "worksheetTitle" is required';
        }
        const sheet = await this.getWorksheet(wsTitle, spreadsheetId);
        const { rowCount = 0, columnCount = 0 } = sheet && sheet.properties && sheet.properties.gridProperties ? sheet.properties.gridProperties : {};
        const sanitizedOptions = Object.assign(Object.assign({}, parsedOptions), { maxCol: parsedOptions.maxCol || columnCount, maxRow: parsedOptions.maxRow || rowCount });
        const res = await this.sheets.spreadsheets.values.get({
            spreadsheetId: spreadsheetId || this.spreadsheetId,
            range: utils_1.getRange(sanitizedOptions),
        });
        const range = lodash_get_1.default(res, 'data.range');
        let values = lodash_get_1.default(res, 'data.values');
        let header = [];
        if (sanitizedOptions.hasHeaderRow) {
            if (!sanitizedOptions.minRow || sanitizedOptions.minRow <= 1) {
                [header, ...values] = values;
            }
            else {
                const res = await this.sheets.spreadsheets.values.get({
                    spreadsheetId: spreadsheetId || this.spreadsheetId,
                    range: utils_1.getRange(Object.assign(Object.assign({}, sanitizedOptions), { worksheetTitle: wsTitle, minRow: 1, maxRow: 1, range: undefined })),
                });
                [header] = lodash_get_1.default(res, 'data.values', [[]]);
                if (!header.length)
                    throw 'No header row exists';
            }
        }
        let maxCol = (sanitizedOptions.maxCol ? sanitizedOptions.maxCol + 1 : 0) - (sanitizedOptions.minCol || 0);
        let maxRow = 0;
        if (values) {
            maxCol = utils_1.getLongestArray(values).length;
            maxRow = values.length;
        }
        // fill missing headings
        for (let c = 0; c < maxCol; c++) {
            header[c] = header[c] || `(${utils_1.colToA(c + (sanitizedOptions.minCol || 0))})`;
        }
        let formatted = [];
        let rawData = [];
        for (let r = 0; r < maxRow; r++) {
            const row = values[r] || [];
            const rawRow = [];
            let set = {};
            for (let c = 0; c < maxCol; c++) {
                const heading = header[c];
                const cell = row[c] || '';
                rawRow[c] = cell;
                set = Object.assign(Object.assign({}, set), { [heading]: cell });
            }
            formatted = [...formatted, set];
            rawData = [...rawData, rawRow];
        }
        return { rawData, formatted, header, range };
    }
    /**
     * Append row data to a worksheet, starting after the last row in a specific column
     *
     * @param {GoogleSheetCli.RawData} data
     * @param {GoogleSheetCli.QueryOptions} options
     * @param {string} [spreadsheetId]
     * @returns {Promise<void>}
     * @memberof GoogleSheet
     */
    async appendData(data, options, spreadsheetId) {
        const { rawData } = await this.getData(options, spreadsheetId);
        options.minRow = rawData.length + 1;
        await this.updateData(data, options, spreadsheetId);
    }
    /**
     * Update the data starting at a specific row and column
     *
     * @param {GoogleSheetCli.RawData} data [['A1', 'A2', 'A3', 'A4', 'A5'], ['B1', 'B2', 'B3', 'B4', 'B5', 'B6']]
     * @param {GoogleSheetCli.QueryOptions} options
     * @param {string} [spreadsheetId]
     * @returns {Promise<void>}
     * @memberof GoogleSheet
     */
    async updateData(data, options, spreadsheetId) {
        options.worksheetTitle = options.worksheetTitle || this.worksheetTitle;
        if (!options.worksheetTitle)
            throw 'Specify worksheetTitle';
        if (!Array.isArray(data) || !data.every(Array.isArray))
            throw 'Check "data" property - has to be supplied as nested array ([["1", "2"], ["3", "4"]])';
        const range = utils_1.getRange(options);
        await this.sheets.spreadsheets.values.update({
            spreadsheetId: spreadsheetId || this.spreadsheetId,
            valueInputOption: options.valueInputOption || GoogleSheetCli.ValueInputOption.RAW,
            range,
            requestBody: {
                values: data,
            },
        });
    }
    /**
     * Add a worksheet with title
     *
     * @param {string} title
     * @param {string} [spreadsheetId]
     * @returns {Promise<sheets_v4.Schema$Sheet>}
     * @memberof GoogleSheet
     */
    async addWorksheet(title, spreadsheetId) {
        const response = await this.sheets.spreadsheets.batchUpdate({
            spreadsheetId: spreadsheetId || this.spreadsheetId,
            requestBody: {
                requests: [
                    {
                        addSheet: {
                            properties: {
                                title,
                            },
                        },
                    },
                ],
            },
        });
        const sheet = lodash_get_1.default(response, 'data.replies[0].addSheet');
        this.worksheetTitle = lodash_get_1.default(sheet, 'properties.title');
        return sheet;
    }
    /**
     * Remove a worksheet by title
     *
     * @param {string} title
     * @param {string} [spreadsheetId]
     * @returns {Promise<void>}
     * @memberof GoogleSheet
     */
    async removeWorksheet(title, spreadsheetId) {
        const sheet = await this.getWorksheet(title, spreadsheetId);
        await this.sheets.spreadsheets.batchUpdate({
            spreadsheetId: spreadsheetId || this.spreadsheetId,
            requestBody: {
                requests: [
                    {
                        deleteSheet: {
                            sheetId: sheet.properties && sheet.properties.sheetId ? sheet.properties.sheetId : -1,
                        },
                    },
                ],
            },
        });
        this.worksheetTitle = '';
    }
    /**
     * Add a spreadsheet with title
     *
     * @param {string} title
     * @returns {Promise<sheets_v4.Schema$Spreadsheet>}
     * @memberof GoogleSheet
     */
    async addSpreadsheet(title) {
        const { data: sheet } = await this.sheets.spreadsheets.create({
            requestBody: {
                properties: {
                    title,
                },
            },
        });
        this.spreadsheetId = sheet.spreadsheetId;
        return sheet;
    }
}
exports.default = GoogleSheet;
