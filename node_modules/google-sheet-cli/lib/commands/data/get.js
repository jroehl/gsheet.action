"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const command_1 = require("@oclif/command");
const cli_ux_1 = tslib_1.__importDefault(require("cli-ux"));
const base_class_1 = tslib_1.__importStar(require("../../lib/base-class"));
class UpdateData extends base_class_1.default {
    async run() {
        const _a = this.parse(UpdateData).flags, { spreadsheetId, rawOutput, minRow, maxRow, minCol, maxCol, range, hasHeaderRow, worksheetTitle } = _a, tableOptions = tslib_1.__rest(_a, ["spreadsheetId", "rawOutput", "minRow", "maxRow", "minCol", "maxCol", "range", "hasHeaderRow", "worksheetTitle"]);
        this.start('Fetching data');
        const res = await this.gsheet.getData({ minRow, maxRow, minCol, maxCol, range, hasHeaderRow, worksheetTitle }, spreadsheetId);
        if (rawOutput) {
            this.logRaw('', Object.assign({ operation: this.id }, res));
            return;
        }
        const { header, formatted } = res;
        const columns = header.reduce((red, col) => {
            return Object.assign(Object.assign({}, red), { [col]: {} });
        }, {});
        this.stop();
        cli_ux_1.default.table(formatted, columns, tableOptions);
    }
}
exports.default = UpdateData;
UpdateData.description = 'Returns cell data';
UpdateData.examples = [
    `$ gsheet data:get --spreadsheetId=<spreadsheetId> --worksheetTitle=<worksheetTitle>

(a)  (b)  (c)
A1   B1   C1
A2   B2   C2
A3   B3   C3
`,
];
UpdateData.flags = Object.assign(Object.assign(Object.assign({}, base_class_1.default.flags), cli_ux_1.default.table.flags()), { spreadsheetId: base_class_1.spreadsheetId,
    worksheetTitle: base_class_1.worksheetTitle, hasHeaderRow: command_1.flags.boolean({ char: 'w', description: 'If the first row should be treated as header row', default: false, required: false }), range: command_1.flags.string({ description: 'The range to use to query the cells', required: false }), minRow: command_1.flags.integer({ description: 'The optional starting row of the operation', default: 1, required: false }), minCol: command_1.flags.integer({ description: 'The optional starting col of the operation', default: 1, required: false }), maxRow: command_1.flags.integer({ description: 'The optional ending row of the operation', required: false }), maxCol: command_1.flags.integer({ description: 'The optional ending col of the operation', required: false }) });
